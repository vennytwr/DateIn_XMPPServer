package server;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.net.ssl.SSLSocketFactory;

import org.jivesoftware.smack.ConnectionConfiguration;
import org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;
import org.jivesoftware.smack.ConnectionListener;
import org.jivesoftware.smack.PacketInterceptor;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.SmackException.NotConnectedException;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketTypeFilter;
import org.jivesoftware.smack.packet.DefaultPacketExtension;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.packet.PacketExtension;
import org.jivesoftware.smack.provider.PacketExtensionProvider;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.jivesoftware.smack.util.StringUtils;
import org.jivesoftware.smack.util.XmlStringBuilder;
import org.json.simple.JSONValue;
import org.json.simple.parser.ParseException;
import org.xmlpull.v1.XmlPullParser;

import payload.PayloadProcessor;
import payload.ProcessorFactory;

public class GcmServer {

	public static final String GCM_SERVER = "gcm.googleapis.com";
	public static final int GCM_PORT = 5235;

	public static final String GCM_ELEMENT_NAME = "gcm";
	public static final String GCM_NAMESPACE = "google:mobile:data";
	
	// Time to live, 2 weeks
	public static long GCM_DEFAULT_TTL = 60 * 60 * 24 * 14;

	private long messageId = 0;
	private XMPPConnection mXmppConnection;
	private static GcmServer sInstance = null;
	private String mApiKey = null;
	private String mProjectId = null;
	/**
	 * Returns a random message id to uniquely identify a message.
	 *
	 * <p>
	 * Note: This is generated by a pseudo random number generator for
	 * illustration purpose, and is not guaranteed to be unique.
	 *
	 */
	public String getMessageId() {
		return "m-" + messageId++;
	}

	/**
	 * XMPP Packet Extension for GCM Cloud Connection Server.
	 */
	class GcmPacketExtension extends DefaultPacketExtension {

		String json;

		public GcmPacketExtension(String json) {
			super(GCM_ELEMENT_NAME, GCM_NAMESPACE);
			this.json = json;
		}

		public String getJson() {
			return json;
		}

		@Override
		public String toXML() {
			return String.format("<%s xmlns=\"%s\">%s</%s>",
					GCM_ELEMENT_NAME, GCM_NAMESPACE,
					StringUtils.escapeForXML(json), GCM_ELEMENT_NAME);
		}

		public Packet toPacket() {
//			Message message = new Message();
//			message.addExtension(this);
//			return message;
			return new Message() {
                // Must override toXML() because it includes a <body>
                @Override
                public XmlStringBuilder toXML() {
                        XmlStringBuilder buf = new XmlStringBuilder();
                        // StringBuilder buf = new StringBuilder();
                        buf.append("<message");
                        if (getXmlns() != null) {
                                buf.append(" xmlns=\"").append(getXmlns()).append("\"");
                        }
                        if (getLanguage() != null) {
                                buf.append(" xml:lang=\"").append(getLanguage())
                                                .append("\"");
                        }
                        if (getPacketID() != null) {
                                buf.append(" id=\"").append(getPacketID()).append("\"");
                        }
                        if (getTo() != null) {
                                buf.append(" to=\"")
                                                .append(StringUtils.escapeForXML(getTo()))
                                                .append("\"");
                        }
                        if (getFrom() != null) {
                                buf.append(" from=\"")
                                                .append(StringUtils.escapeForXML(getFrom()))
                                                .append("\"");
                        }
                        buf.append(">");
                        buf.append(GcmPacketExtension.this.toXML());
                        buf.append("</message>");
                        return buf;
                }
			};
		}
	}

	public static GcmServer getInstance() {
		if(sInstance == null) {
			throw new IllegalStateException("You have to prepare the XmppServver first..");
		}
		return sInstance;
	}

	public static GcmServer prepareServer(String projectId, String apiKey, boolean debug) {
		synchronized(GcmServer.class) {
			if(sInstance == null) {
				sInstance = new GcmServer(projectId, apiKey, debug);
			}
		}
		return sInstance;
	}

	private GcmServer(String projectId, String apiKey, boolean debug) {
		this();
		mApiKey = apiKey;
		mProjectId = projectId;
	}

	private GcmServer() {
		ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE, 
				new PacketExtensionProvider() {

			@Override
			public PacketExtension parseExtension(XmlPullParser parser) throws Exception {
				String json = parser.nextText();
				GcmPacketExtension packet = new GcmPacketExtension(json);
				return packet;
			}
		});
	}

	private XmppMessage getMessage(Map<String, Object> jsonObject) {
		String from = jsonObject.get("from").toString();
		String category = jsonObject.get("category").toString();
		String messageId = jsonObject.get("message_id").toString();

		@SuppressWarnings("unchecked")
		Map<String, String> payload = (Map<String, String>) jsonObject.get("data");

		XmppMessage msg = new XmppMessage(from, category, messageId, payload);

		return msg;
	}

	/**
	 * Sends a downstream GCM message
	 */
	public void send(String jsonRequest) {
		Packet request = new GcmPacketExtension(jsonRequest).toPacket();
		try {
			mXmppConnection.sendPacket(request);
		} catch (NotConnectedException e) {
			System.out.println("Not connected, therefore unable to send packet.");
		}
	}

	/**
	 * Sends a message to multiple recipients. Kind of like the old
	 * HTTP message with the list of regIds in the "registration_ids" field.
	 */

	//	public void sendBroadcast(Map<String, String> payload, String collapseKey,
	//            long timeToLive, Boolean delayWhileIdle, List<String> recipients) {
	//		Map map = createAttributeMap(null, null, payload, collapseKey,
	//                    timeToLive, delayWhileIdle);
	//        for (String toRegId: recipients) {
	//            String messageId = getRandomMessageId();
	//            map.put("message_id", messageId);
	//            map.put("to", toRegId);
	//            String jsonRequest = createJsonMessage(map);
	//            send(jsonRequest);
	//        }
	//    }

	/**
	 * Handles an upstream data message from a device application.
	 */
	public void handleIncomingDataMessage(XmppMessage msg) {
		if (msg.getPayload().get("action") != null) {
			PayloadProcessor processor = ProcessorFactory.getProcessor(msg.getPayload().get("action"));
			processor.handleMessage(msg);
		}   
	}

	/**
	 * Handles an ACK.
	 *
	 * <p>
	 * By default, it only logs a INFO message, but subclasses could override it
	 * to properly handle ACKS.
	 */
	public void handleAckReceipt(Map<String, Object> jsonObject) {
		String messageId = jsonObject.get("message_id").toString();
		String from = jsonObject.get("from").toString();
		System.out.println("handleAckReceipt() from: " + from + ", messageId: " + messageId);
		//mLogger.log(Level.INFO, "handleAckReceipt() from: " + from + ", messageId: " + messageId + "\n");
	}

	/**
	 * Handles a NACK.
	 *
	 * <p>
	 * By default, it only logs a INFO message, but subclasses could override it
	 * to properly handle NACKS.
	 */
	public void handleNackReceipt(Map<String, Object> jsonObject) {
		String messageId = jsonObject.get("message_id").toString();
		String from = jsonObject.get("from").toString();
		System.out.println("handleNackReceipt() from: " + from + ", messageId: " + messageId);
		//mLogger.log(Level.INFO, "handleNackReceipt() from: " + from + ", messageId: " + messageId + "\n");
	}

	/**
	 * Creates a JSON encoded GCM message.
	 *
	 * @param to RegistrationId of the target device (Required).
	 * @param messageId Unique messageId for which CCS will send an "ack/nack"
	 * (Required).
	 * @param payload Message content intended for the application. (Optional).
	 * @param collapseKey GCM collapse_key parameter (Optional).
	 * @param timeToLive GCM time_to_live parameter (Optional).
	 * @param delayWhileIdle GCM delay_while_idle parameter (Optional).
	 * @return JSON encoded GCM message.
	 */
	public static String createJsonMessage(String to, String messageId, Map<String, String> payload,
			String collapseKey, Long timeToLive, Boolean delayWhileIdle) {
		return createJsonMessage(createAttributeMap(to, messageId, payload,
				collapseKey, timeToLive, delayWhileIdle));
	}

	@SuppressWarnings("rawtypes")
	public static String createJsonMessage(Map map) {
		return JSONValue.toJSONString(map);
	}

	@SuppressWarnings("rawtypes")
	public static Map createAttributeMap(String to, String messageId, Map<String, String> payload,
			String collapseKey, Long timeToLive, Boolean delayWhileIdle) {
		Map<String, Object> message = new HashMap<String, Object>();
		if (to != null) {
			message.put("to", to);
		}
		if (collapseKey != null) {
			message.put("collapse_key", collapseKey);
		}
		if (timeToLive != null) {
			message.put("time_to_live", timeToLive);
		}
		if (delayWhileIdle != null && delayWhileIdle) {
			message.put("delay_while_idle", true);
		}
		if (messageId != null) {
			message.put("message_id", messageId);
		}
		message.put("data", payload);
		return message;
	}

	/**
	 * Creates a JSON encoded ACK message for an upstream message received from
	 * an application.
	 *
	 * @param to RegistrationId of the device who sent the upstream message.
	 * @param messageId messageId of the upstream message to be acknowledged to
	 * CCS.
	 * @return JSON encoded ack.
	 */
	public static String createJsonAck(String to, String messageId) {
		Map<String, Object> message = new HashMap<String, Object>();
		message.put("message_type", "ack");
		message.put("to", to);
		message.put("message_id", messageId);
		return JSONValue.toJSONString(message);
	}

	/// new: NACK added
	/**
	 * Creates a JSON encoded NACK message for an upstream message received from
	 * an application.
	 *
	 * @param to RegistrationId of the device who sent the upstream message.
	 * @param messageId messageId of the upstream message to be acknowledged to
	 * CCS.
	 * @return JSON encoded ack.
	 */
	public static String createJsonNack(String to, String messageId) {
		Map<String, Object> message = new HashMap<String, Object>();
		message.put("message_type", "ack");
		message.put("to", to);
		message.put("message_id", messageId);
		return JSONValue.toJSONString(message);
	}
	
	public void disconnect() {
		try {
			mXmppConnection.disconnect();
		} catch (NotConnectedException e) {
			System.out.println("Not connected, therefore unable to disconnect.");
		}
	}

	public void connect() throws XMPPException, SmackException, IOException {
		ConnectionConfiguration mConfig = new ConnectionConfiguration(GCM_SERVER, GCM_PORT);
		mConfig.setSecurityMode(SecurityMode.enabled);
		mConfig.setReconnectionAllowed(true);
		mConfig.setRosterLoadedAtLogin(false);
		mConfig.setSendPresence(false);

		mConfig.setSocketFactory(SSLSocketFactory.getDefault());

		// NOTE: Set to true to launch a window with information about packets sent and received
		mConfig.setDebuggerEnabled(true);

		mXmppConnection = new XMPPTCPConnection(mConfig);
		mXmppConnection.connect();
		System.out.println("GCM Connection Established.");

		mXmppConnection.addConnectionListener(new ConnectionListener() {
			@Override
			public void authenticated(XMPPConnection arg0) {
				System.out.println("Authenticated.");
				System.out.println("Logged In: " + mProjectId);
			}

			@Override
			public void connected(XMPPConnection arg0) {
				System.out.println("Connected.");
			}

			@Override
			public void connectionClosed() {
				System.out.println("Connection closed.");
			}

			@Override
			public void connectionClosedOnError(Exception arg0) {
				System.out.println("Connection closed on error");
			}

			@Override
			public void reconnectingIn(int seconds) {
				System.out.println("Reconnecting in " + seconds + " secs\n");
			}

			@Override
			public void reconnectionFailed(Exception arg0) {
				System.out.println("Reconnection failed.");
			}

			@Override
			public void reconnectionSuccessful() {
				System.out.println("Reconnected.");
			}
		});

		// Handle incoming packets
		mXmppConnection.addPacketListener(new PacketListener() {
			@Override
			public void processPacket(Packet packet) {
				System.out.println("Received: " + packet.toXML());

				Message incomingMessage = (Message) packet;
				GcmPacketExtension gcmPacket
				= (GcmPacketExtension) incomingMessage.getExtension(GCM_NAMESPACE);
				String json = gcmPacket.getJson();
				try {
					@SuppressWarnings("unchecked")
					Map<String, Object> jsonMap
					= (Map<String, Object>) JSONValue.parseWithException(json);

					handleMessage(jsonMap);
				} catch (ParseException e) {
					System.out.println("ERROR: Parasing JSON " + json + " | " + e);
				} catch (Exception e) {
					System.out.println("ERROR: Couldn't send echo. " + e);
				}
			}
		}, new PacketTypeFilter(Message.class));

		// Log all outgoing packets
		mXmppConnection.addPacketInterceptor(new PacketInterceptor() {
			@Override
			public void interceptPacket(Packet packet) {
				System.out.println("Sent: " + packet.toXML());
				//mLogger.log(Level.INFO, "Sent: {0}", packet.toXML());
			}
		}, new PacketTypeFilter(Message.class));

		System.out.println("Authenticating..");
		mXmppConnection.login(mProjectId + "@gcm.googleapis.com", mApiKey);
	}

	private void handleMessage(Map<String, Object> jsonMap) {
		// present for "ack"/"nack", null otherwise
		Object messageType = jsonMap.get("message_type");

		if (messageType == null) {
			XmppMessage msg = getMessage(jsonMap);
			// Normal upstream data message
			try {
				handleIncomingDataMessage(msg);
				// Send ACK to CCS
				String ack = createJsonAck(msg.getFrom(), msg.getMessageId());
				send(ack);
			}
			catch (Exception e) {
				// Send NACK to CCS
				String nack = createJsonNack(msg.getFrom(), msg.getMessageId());
				send(nack);
			}
		} else if ("ack".equals(messageType.toString()))
			handleAckReceipt(jsonMap);
		else if ("nack".equals(messageType.toString()))
			handleNackReceipt(jsonMap);
		else
			System.out.println("Unrecognized message type(%s), " + messageType.toString());
	}

}
